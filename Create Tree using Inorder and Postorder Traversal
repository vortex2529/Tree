#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;



class Node{
    public:
    int data;
    Node* left;
    Node* right;

    Node(int _data):data(_data),left(NULL),right(NULL){}
};

void LevelOrderTraversal_PrintLevelWise(Node* root){
  queue<Node*> q;

  q.push(root);
  q.push(NULL);

  while(!q.empty()){

    Node* temp = q.front();
    q.pop();
    if(temp == NULL){
      cout<<endl;
      if(!q.empty()){
        q.push(NULL);
      }
    }
    else{
      cout<<temp->data<<" ";
      if(temp->left){
        q.push(temp->left);
      }
      if(temp->right){
        q.push(temp->right);
      }
    } 
  }
}

int findPos(vector<int> &inorder,int n,int element){
  for(int i=0;i<n;i++){
    if(element == inorder[i]){
      return i;
    }
  }
  return -1;
}

Node* buildtreeUsingInorderPostorder(vector<int> &inorder,vector<int> &postorder,int &size,int &postIndex,int inStart,int inEnd){
    if(postIndex < 0 || inStart > inEnd) return NULL;

    // step A:create root
    int element = postorder[postIndex--];
    Node* root = new Node(element);

    int pos = findPos(inorder,size,element);
    // step B:right call
    root->right = buildtreeUsingInorderPostorder(inorder,postorder,size,postIndex,pos+1,inEnd);
    // step C:left call
    root->left = buildtreeUsingInorderPostorder(inorder,postorder,size,postIndex,inStart,pos-1);

    return root;
}

Node* buildtreeUsingInorderPostorder_withMap(vector<int> &inorder,vector<int> &postorder,int &size,int &postIndex,int inStart,int inEnd,unordered_map<int,int> &posMap){
    if(postIndex < 0 || inStart > inEnd) return NULL;

    // step A:create root
    int element = postorder[postIndex--];
    Node* root = new Node(element);

    int pos = posMap[element];
    // step B:right call
    root->right = buildtreeUsingInorderPostorder_withMap(inorder,postorder,size,postIndex,pos+1,inEnd,posMap);
    // step C:left call
    root->left = buildtreeUsingInorderPostorder_withMap(inorder,postorder,size,postIndex,inStart,pos-1,posMap);

    return root;
}

int main() {
  vector<int> inorder = {40,20,10,50,30,60};
  vector<int> postorder = {40,20,50,60,30,10};

  int size = postorder.size();
  int inStart = 0;
  int inEnd = size-1;

  int postIndex1 = size-1;
  Node* root = buildtreeUsingInorderPostorder(inorder,postorder,size,postIndex1,inStart,inEnd);


  unordered_map<int,int> posMap;
  for(int i=0;i<size;i++){
    posMap[inorder[i]] = i;
  }
  int postIndex2 = size-1;
  Node* root1 = buildtreeUsingInorderPostorder_withMap(inorder,postorder,size,postIndex2,inStart,inEnd,posMap);

  // Brute force
  cout<<"Printing tree created from Inorder & Postorder Traversal :"<<endl;
  LevelOrderTraversal_PrintLevelWise(root);
  cout<<endl;

  
  // optimized approach using map
  cout<<"Printing tree created from Inorder & Postorder Traversal using map :"<<endl;
  LevelOrderTraversal_PrintLevelWise(root1);
  cout<<endl;



  return 0;
}




